# 对于不同 GC 和堆内存的总结



## 串行GC

对于年轻代和老年代都是用单线程进行处理，无法充分利用多核CPU，适合几百MB堆内存单核CPU的机器，堆内存较大时会使GC暂停时间过长

## 并行GC

JDK678的默认GC，串行GC的改进版，可以充分利用多核CPU，大幅降低GC暂停时间，提高了吞吐量，适合优先考虑吞吐量的系统

对于绝大部分Java应用系统，堆内存2-4G左右，对于低延迟的GC暂停不敏感，优先追求系统的吞吐量，这时候最适合用并行GC

## CMSGC

对年轻代采用并行处理，对老年代采用并发处理（大部分工作与业务线程一起并发执行），适合多核CPU且优先考虑低延迟，每次GC时间尽量短的场景

## G1GC

JDK9之后的默认GC，划分为多个小堆块进行增量回收，进一步降低了单次GC暂停的时间，适合堆内存4G以上的系统

## ZGC/Shenandoah GC

通过着色指针和读屏障，实现几乎全部的并发执行，GC最大停顿时间不超过10ms，支持超大内存，与G1相比，应用吞吐量下降不超过15%，适合堆内存非常大（超过16G，甚至是64G、128G），或者对延迟非常敏感的系统











